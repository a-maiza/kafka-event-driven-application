name: CD Pipeline

on:
  push:
    branches: [main]
  release:
    types: [published]

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ghcr.io/a-maiza
  SERVICES: order-service payment-service inventory-service status-service query-service streams-analytics-service

jobs:
  build-and-push:
    name: Build & Push Images
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.tag }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Java 21
        uses: actions/setup-java@v4
        with:
          distribution: corretto
          java-version: '21'
          cache: maven

      - name: Build and test
        run: mvn verify -q

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine image tag
        id: meta
        run: |
          if [ "${{ github.event_name }}" = "release" ]; then
            TAG="${{ github.event.release.tag_name }}"
          else
            TAG="${GITHUB_SHA::7}"
          fi
          echo "tag=$TAG" >> "$GITHUB_OUTPUT"
          echo "Image tag: $TAG"

      - name: Build and push Docker images
        run: |
          TAG="${{ steps.meta.outputs.tag }}"
          for SERVICE in $SERVICES; do
            echo "=== Building $SERVICE ==="
            docker build \
              -f "$SERVICE/Dockerfile" \
              -t "$IMAGE_PREFIX/$SERVICE:$TAG" \
              -t "$IMAGE_PREFIX/$SERVICE:latest" \
              .
            echo "=== Pushing $SERVICE ==="
            docker push "$IMAGE_PREFIX/$SERVICE:$TAG"
            docker push "$IMAGE_PREFIX/$SERVICE:latest"
          done

  deploy-dev:
    name: Deploy to Dev
    needs: build-and-push
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    environment: dev

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Helm
        uses: azure/setup-helm@v4

      - name: Configure kubectl
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG_DEV }}" | base64 -d > ~/.kube/config

      - name: Deploy to dev
        run: |
          helm upgrade --install kafka-platform ./helm/kafka-platform \
            --set global.imageTag=${{ needs.build-and-push.outputs.image-tag }} \
            --wait --timeout 5m

  deploy-staging:
    name: Deploy to Staging
    needs: [build-and-push, deploy-dev]
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    environment: staging

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Helm
        uses: azure/setup-helm@v4

      - name: Configure kubectl
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > ~/.kube/config

      - name: Deploy to staging
        run: |
          helm upgrade --install kafka-platform ./helm/kafka-platform \
            -f ./helm/kafka-platform/values-staging.yaml \
            --set global.imageTag=${{ needs.build-and-push.outputs.image-tag }} \
            --wait --timeout 5m

  deploy-prod:
    name: Deploy to Production
    needs: build-and-push
    if: github.event_name == 'release'
    runs-on: ubuntu-latest
    environment: prod

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Helm
        uses: azure/setup-helm@v4

      - name: Configure kubectl
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBE_CONFIG_PROD }}" | base64 -d > ~/.kube/config

      - name: Deploy to production
        run: |
          helm upgrade --install kafka-platform ./helm/kafka-platform \
            -f ./helm/kafka-platform/values-prod.yaml \
            --set global.imageTag=${{ needs.build-and-push.outputs.image-tag }} \
            --wait --timeout 10m

  smoke-test:
    name: Smoke Test
    needs: [deploy-dev, deploy-staging, deploy-prod]
    if: always() && (needs.deploy-dev.result == 'success' || needs.deploy-staging.result == 'success' || needs.deploy-prod.result == 'success')
    runs-on: ubuntu-latest

    steps:
      - name: Configure kubectl
        run: |
          mkdir -p ~/.kube
          # Use the last successful deployment's kube config
          if [ "${{ needs.deploy-prod.result }}" = "success" ]; then
            echo "${{ secrets.KUBE_CONFIG_PROD }}" | base64 -d > ~/.kube/config
          elif [ "${{ needs.deploy-staging.result }}" = "success" ]; then
            echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > ~/.kube/config
          else
            echo "${{ secrets.KUBE_CONFIG_DEV }}" | base64 -d > ~/.kube/config
          fi

      - name: Smoke test services
        run: |
          SERVICES="order-service payment-service inventory-service status-service query-service streams-analytics-service"
          FAILED=0

          for SERVICE in $SERVICES; do
            echo "--- Testing $SERVICE ---"
            # Port-forward and check health endpoint
            kubectl port-forward "svc/$SERVICE" 8080:8080 &
            PF_PID=$!
            sleep 3

            STATUS=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/actuator/health 2>/dev/null || echo "000")
            kill $PF_PID 2>/dev/null || true
            wait $PF_PID 2>/dev/null || true

            if [ "$STATUS" = "200" ]; then
              echo "OK: $SERVICE is healthy"
            else
              echo "WARN: $SERVICE returned HTTP $STATUS"
              FAILED=$((FAILED + 1))
            fi
          done

          if [ $FAILED -gt 0 ]; then
            echo ""
            echo "WARNING: $FAILED service(s) did not return healthy status"
            # Don't fail the pipeline â€” smoke tests are advisory
          else
            echo ""
            echo "All services are healthy."
          fi
